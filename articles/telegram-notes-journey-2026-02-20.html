<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/alpacanotes/_next/static/css/87ceaea6f9666f43.css" data-precedence="next"/><link rel="stylesheet" href="/alpacanotes/_next/static/css/3afc2e1f55a0942b.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/alpacanotes/_next/static/chunks/webpack-1ed120f40a346afc.js"/><script src="/alpacanotes/_next/static/chunks/4bd1b696-018d5d15d5e61bde.js" async=""></script><script src="/alpacanotes/_next/static/chunks/517-4eb3cab2fd928649.js" async=""></script><script src="/alpacanotes/_next/static/chunks/main-app-498d8712a9aaaeae.js" async=""></script><script src="/alpacanotes/_next/static/chunks/app/layout-50006a05f4f38e04.js" async=""></script><script src="/alpacanotes/_next/static/chunks/935-c3c4a42486495e3b.js" async=""></script><script src="/alpacanotes/_next/static/chunks/30-cde6a761eaef6c52.js" async=""></script><script src="/alpacanotes/_next/static/chunks/598-8424641e72451bd5.js" async=""></script><script src="/alpacanotes/_next/static/chunks/app/articles/%5Bid%5D/page-b4c9447121244ee6.js" async=""></script><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-99PGBGJH4S" as="script"/><title>从一个念头到自动化链路：Telegram 碎碎念入站记 - AlpacaNotes</title><meta name="description" content="记录把 Telegram 随手笔记自动汇总到博客 Notes 页面的全过程，包括方案选型、逐步落地和一路踩过的坑。"/><meta property="og:title" content="从一个念头到自动化链路：Telegram 碎碎念入站记 - AlpacaNotes"/><meta property="og:description" content="记录把 Telegram 随手笔记自动汇总到博客 Notes 页面的全过程，包括方案选型、逐步落地和一路踩过的坑。"/><meta property="og:url" content="https://linguista.cn/alpacanotes/articles/telegram-notes-journey-2026-02-20"/><meta property="og:image" content="https://linguista.cn/alpacanotes/aztecaalpaca.jpg"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2026-02-20"/><meta property="article:author" content="@linguista2025"/><meta property="article:tag" content="Telegram"/><meta property="article:tag" content="GitHub Actions"/><meta property="article:tag" content="Cloudflare Workers"/><meta property="article:tag" content="自动化"/><meta property="article:tag" content="开发记录"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="从一个念头到自动化链路：Telegram 碎碎念入站记 - AlpacaNotes"/><meta name="twitter:description" content="记录把 Telegram 随手笔记自动汇总到博客 Notes 页面的全过程，包括方案选型、逐步落地和一路踩过的坑。"/><meta name="twitter:image" content="https://linguista.cn/alpacanotes/aztecaalpaca.jpg"/><link rel="icon" href="/alpacanotes/favicon.svg" type="image/svg+xml"/><script src="/alpacanotes/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased min-h-screen"><script>((e,t,r,n,o,a,i,u)=>{let s=document.documentElement,l=["light","dark"];function c(t){(Array.isArray(e)?e:[e]).forEach(e=>{let r="class"===e,n=r&&a?o.map(e=>a[e]||e):o;r?(s.classList.remove(...n),s.classList.add(a&&a[t]?a[t]:t)):s.setAttribute(e,t)}),u&&l.includes(t)&&(s.style.colorScheme=t)}if(n)c(n);else try{let e=localStorage.getItem(t)||r,n=i&&"system"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e;c(n)}catch(e){}})("class","theme","system",null,["light","dark"],null,true,true)</script><main class="min-h-screen pb-20"><header class="py-8 mb-12"><div class="max-w-6xl mx-auto px-6 flex justify-between items-center relative z-50"><a class="text-accent font-extrabold text-2xl tracking-tight hover:opacity-80 transition-opacity" href="/alpacanotes">AlpacaNotes</a><nav class="hidden md:flex items-center gap-8 text-base font-semibold text-muted"><a class="hover:text-foreground transition-colors" href="/alpacanotes/articles">Articles</a><a class="hover:text-foreground transition-colors" href="/alpacanotes/notes">Notes</a><a class="hover:text-foreground transition-colors" href="/alpacanotes/tweets">Tweets</a><a class="hover:text-foreground transition-colors" href="/alpacanotes/topics">Topics</a><a class="hover:text-foreground transition-colors" href="/alpacanotes/prompts">Prompts</a><a class="hover:text-foreground transition-colors" href="/alpacanotes/rss.xml">RSS</a><div class="pl-6 border-l border-border-subtle flex items-center"><button class="p-2 transition-opacity hover:opacity-80" aria-label="Toggle theme"><div class="w-6 h-6 rounded-full border border-[var(--accent)]" style="background:linear-gradient(90deg, var(--accent) 50%, #ffffff 50%)"></div><span class="sr-only">Toggle theme</span></button></div></nav><div class="md:hidden flex items-center gap-4"><button class="p-2 transition-opacity hover:opacity-80" aria-label="Toggle theme"><div class="w-6 h-6 rounded-full border border-[var(--accent)]" style="background:linear-gradient(90deg, var(--accent) 50%, #ffffff 50%)"></div><span class="sr-only">Toggle theme</span></button><button class="text-muted hover:text-foreground transition-colors p-2 -mr-2" aria-label="Toggle menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button></div></div></header><article class="container-custom relative md-theme-amp-outer"><header class="mb-10"><h1 class="text-3xl md:text-4xl font-bold mb-4 text-center font-serif text-[#3e3832] dark:text-[#f0f6fc]">从一个念头到自动化链路：Telegram 碎碎念入站记</h1><p class="text-xl text-muted mb-4">一天之内打通 Telegram → GitHub → 博客的随手记功能</p><div class="text-sm text-muted">2026-02-20</div></header><div class="prose md-theme-amp"><p>事情的起因很简单：我想要一个"随手记"的地方。</p>
<p>平时看到什么、想到什么，顺手发一条消息就完事了。但这些零碎的想法散落在聊天记录里或者仅存在与脑海之中，过几天就沉没了。我希望它们能自动汇集到博客的 Notes 页面上——每天的消息归到同一篇，标题就是当天日期，像一份"碎碎念合集"。</p>
<p>需求说起来就一句话，但真正动手做的时候，发现牵扯的东西远比想象中多，不过好在，基于Codex的给力输出，一下午就把基本功能搞定了。</p>
<h2 id="选方案为什么是-telegram-bot-webhook">选方案：为什么是 Telegram Bot Webhook</h2>
<p>一开始摆在面前的核心问题是：怎么把 Telegram 里的消息送到 GitHub 仓库？</p>
<p>最终选定的方案是 Telegram Bot Webhook。简单说，Webhook 就是"你给我一个网址，有事我主动来敲门"——Telegram 每次收到消息，会主动把内容 POST 到我指定的地址，而不是我反复去轮询"有没有新消息"。</p>
<p>思路是这样的：我建一个 Bot，私聊发文本给它，Telegram 会把消息推送到 Webhook 地址。Webhook 收到消息后，调用 GitHub API 触发一个 <code>repository_dispatch</code> 事件（可以理解为"远程拍一下 GitHub 的肩膀，告诉它该干活了"），然后 GitHub Actions 接手，把消息内容写入当天的 Markdown 文件，提交到仓库。最后靠现有的部署流程自动发布到站点。</p>
<p>整条链路画出来大概是这样的：</p>
<blockquote>
<p>Telegram 私聊 → Bot Webhook → Cloudflare Worker → GitHub repository_dispatch → Actions 脚本写入 notes → commit &#x26; push → 定时部署到 Pages</p>
</blockquote>
<p>看起来环节不少，但每一环的职责都很清晰。Webhook 只做"接收和转发"，Actions 脚本只做"写文件"，部署还是复用原来的流程。</p>
<h2 id="关于-cloudflare-workers一个意外的知识盲区">关于 Cloudflare Workers：一个意外的知识盲区</h2>
<p>说来有点惭愧，一开始我甚至不太清楚 Cloudflare Workers 是什么。我的第一反应是：能不能直接用我现有的 GitHub Pages 域名来接 Webhook？</p>
<p>答案当然是不行——GitHub Pages 是纯静态托管，只能返回 HTML/CSS/JS 文件，没法处理 POST 请求和执行业务逻辑。打个比方，静态托管就像一个只会发传单的展位，你递给它一封信（POST 请求），它不知道怎么拆开、怎么处理。所以还是需要一个真正的"后端入口"，哪怕它只有几十行代码。</p>
<p>Cloudflare Workers 本质上就是一个托管在云端的小型后端函数——你可以把它想象成一个 24 小时在线的小助手，有人敲门（收到请求）它就按你写好的逻辑去办事，办完就休息，不用你租一台一直开着的服务器。免费额度对我这个场景绰绰有余，部署也就是把代码粘进去点一下的事。唯一需要配置的是五个环境变量：Telegram 的 secret token（用来验证请求确实来自 Telegram）、我的聊天 ID 白名单（只接受我自己发的消息）、GitHub 仓库信息和一个最小权限的 PAT（Personal Access Token，相当于 GitHub 的"临时通行证"，只给它读写仓库文件的权限）。</p>
<h2 id="第一个坑worker-还是默认模板">第一个坑：Worker 还是默认模板</h2>
<p>所有代码写好、环境变量配好之后，我兴冲冲地给 Bot 发了第一条消息。</p>
<p>Cloudflare 的日志确实收到了请求——但 GitHub Actions 毫无动静。</p>
<p>我去看 Worker 的日志，发现一行非常眼熟的输出：<code>Hello World Worker received a request!</code>。原来我在 Cloudflare 的编辑器里创建 Worker 之后，忘了把默认模板替换成真正的 webhook 代码。它确实收到了 Telegram 的请求，但只是礼貌地回了一句"Hello World"，根本没有调用 GitHub API。</p>
<p>把代码替换上去、重新部署之后，这一环就通了。</p>
<h2 id="第二个坑并发推送导致-non-fast-forward">第二个坑：并发推送导致 non-fast-forward</h2>
<p>消息终于能写入仓库了，但新的问题很快出现。</p>
<p>当我短时间内连发几条消息时，GitHub Actions 的 ingest workflow（负责把消息写入文件的自动化流程）会多次并行运行。每个 run 都是拉取 main 分支最新代码、修改文件、提交、推送——但如果前一个 run 已经推送成功，后一个 run 手里的代码就"过时"了，<code>git push</code> 直接被拒绝，报错信息是 <code>non-fast-forward</code>（直译就是"你的版本不是最新的，不能直接往前推"）。</p>
<p>解决办法不复杂：在 workflow 里给 push 加了重试逻辑，失败时自动拉取远端最新代码、把自己的改动接在后面（<code>git pull --rebase</code>），然后重新推送，最多重试四次。同时也加了空变更保护——如果这条消息已经被前一个 run 写入了（也就是做了<strong>幂等去重</strong>，下面会解释），就不做无意义的提交。</p>
<h2 id="第三个坑时间显示错乱">第三个坑：时间显示错乱</h2>
<p>写入链路稳定之后，我打开网页一看——时间不对。</p>
<p>我发的消息明明是北京时间下午 6 点，页面上却显示成了上午 10 点。原因也不难猜：ingest 脚本在 <code>date</code> 字段里写入了带 <code>+08:00</code> 时区后缀的 ISO 格式（比如 <code>2026-02-20T18:02:51+08:00</code>），但站点的构建服务器在 UTC 时区（比北京时间慢 8 小时），渲染的时候直接按 UTC 解读，6 点减 8 小时就变成了上午 10 点。</p>
<p>第一次修复的思路是"在前端强制按 Asia/Shanghai 时区格式化"。写了几个工具函数，改了列表页、详情页和首页组件。改完确实对了——但我随即意识到一个问题：之前所有手写的文章都用的是不带时区的日期格式（比如 <code>"Jan 17 2026"</code> 或 <code>"2026-01-24"</code>），这套新逻辑会不会影响旧文章的显示？</p>
<p>最终的决策是"以旧规则为准"：前端的时间展示逻辑全部恢复原样，ingest 脚本那边改成写入不带时区后缀的格式，和旧文章保持一致。</p>
<h2 id="第四个坑定时部署不触发">第四个坑：定时部署不触发</h2>
<p>GitHub 有一个防循环机制：由自动化流程（<code>GITHUB_TOKEN</code>）推送的代码变更，不会再触发其他由 push 事件启动的 workflow。这是为了防止"A 触发 B，B 又触发 A"的无限循环。但副作用是：ingest workflow 写完 notes 文件并 push 之后，deploy workflow 压根不知道有新内容，不会自动启动部署。</p>
<p>我先是加了 <code>workflow_run</code> 触发，让 deploy 监听 ingest 完成后自动运行。但这样每条消息都会触发一次完整构建，太频繁了。</p>
<p>后来改成了"双通道"策略：</p>
<ul>
<li>我自己手动 push 到 main → 立即部署</li>
<li>Bot 自动写入 → 不立即部署，靠每 30 分钟一次的定时任务检查是否有新变更，有就部署，没有就跳过</li>
</ul>
<p>这个策略本身没问题，但实际跑起来又碰到了新状况：定时任务的"是否需要部署"检查逻辑有 bug。它去查"最近一次成功的 deploy run"，结果把 bot push 触发但被 <code>if</code> 条件跳过的 run 也算进去了——那个 run 的 <code>head_sha</code> 恰好就是最新的，于是检查结论永远是"不需要部署"。</p>
<p>修复方式是把并发组按事件类型拆分，同时让 schedule-check 只认"真正执行过构建的成功 run"，排除掉被跳过的那些。</p>
<h2 id="一个小插曲dependabot-带来的分支爆炸">一个小插曲：Dependabot 带来的分支爆炸</h2>
<p>在处理主线功能的间隙，我顺手给仓库加了 Dependabot 来自动更新依赖——毕竟 <code>npm audit</code> 报了一堆告警，其中 Next.js 还有个 critical。</p>
<p>结果push一波之后发现，仓库多出了十几个 <code>dependabot/...</code> 分支，每个依赖包一个 PR。虽然是正常行为，但对于一个人维护的小项目来说，这些 PR 看着就让人焦虑。</p>
<p>先是改成了分组更新模式（npm 一组、actions 一组），后来想了想，干脆关掉了——对我来说，偶尔手动跑一次 <code>npm update</code> 比每周审核一堆自动 PR 更省心。</p>
<h2 id="回过头来看">回过头来看</h2>
<p>这半天下来，从萌生"随手记"的念头到整条链路基本跑通，中间经历了方案评估、代码实现、环境配置、五六轮问题排查和策略调整。真正写代码的时间可能并不算多，大部分精力花在了"让各个环节正确地衔接起来"上。</p>
<p>有几个收获值得记下来：</p>
<p><strong>写入和发布应该解耦。</strong> "解耦"说白了就是把两件事拆开、各管各的。一开始我本能地觉得"消息写进去就应该立刻发布"，但实际上对于碎碎念这种内容，延迟几十分钟完全可以接受。把"写入仓库"和"构建发布网站"拆成两个独立的步骤之后，构建频率降下来了，并发冲突也少了。</p>
<p><strong>幂等性不是可选项。</strong> 所谓"幂等"，就是"同一个操作执行一次和执行一百次，结果都一样"。在这个场景里，Telegram 会重试、Actions 会并发、网络会抖动，同一条消息可能被投递多次。如果 ingest 脚本不按 <code>message_id</code> 做去重——也就是"这条消息已经写过了，再来一次我就跳过"——那同一条碎碎念可能会在页面上出现好几遍。这种"不管来多少次都只生效一次"的防御性设计，在一开始就该想到。</p>
<p><strong>尊重已有的约定。</strong> 时区格式的问题本质上就是"新代码没有遵循旧约定"。与其让新功能强推一套新格式，不如让它适配已有的规则，哪怕那个规则不是最"正确"的。</p>
<p>现在这套东西已经能用了：给 Bot 发条消息，等半小时，网站上就能看到。后续要做的事情不多——观察定时部署的稳定性、找时间升级一下 Next.js 版本、可能的话给 ingest 加几条日志方便排查。</p>
<p>总之，它从一个"要是能这样就好了"的念头，变成了一条真正可用的自动化链路。这大概就是折腾的乐趣所在。</p></div><div class="mt-16 pt-8 border-t border-[var(--border-subtle)]"><a class="text-accent hover:text-foreground transition-colors" href="/alpacanotes/articles">← Back to Articles</a></div></article></main><script src="/alpacanotes/_next/static/chunks/webpack-1ed120f40a346afc.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"3:\"$Sreact.fragment\"\n4:I[6498,[\"177\",\"static/chunks/app/layout-50006a05f4f38e04.js\"],\"default\"]\n5:I[8312,[\"177\",\"static/chunks/app/layout-50006a05f4f38e04.js\"],\"ThemeProvider\"]\n6:I[5244,[],\"\"]\n7:I[3866,[],\"\"]\n9:I[6213,[],\"OutletBoundary\"]\nb:I[6213,[],\"MetadataBoundary\"]\nd:I[6213,[],\"ViewportBoundary\"]\nf:I[4835,[],\"\"]\n1:HL[\"/alpacanotes/_next/static/css/87ceaea6f9666f43.css\",\"style\"]\n2:HL[\"/alpacanotes/_next/static/css/3afc2e1f55a0942b.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"XYn5gDO-iytjF3OhbcQpe\",\"p\":\"/alpacanotes\",\"c\":[\"\",\"articles\",\"telegram-notes-journey-2026-02-20\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"articles\",{\"children\":[[\"id\",\"telegram-notes-journey-2026-02-20\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$3\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/alpacanotes/_next/static/css/87ceaea6f9666f43.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/alpacanotes/_next/static/css/3afc2e1f55a0942b.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased min-h-screen\",\"children\":[[\"$\",\"$L4\",null,{}],[\"$\",\"$L5\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"disableTransitionOnChange\":true,\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}],{\"children\":[\"articles\",[\"$\",\"$3\",\"c\",{\"children\":[null,[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"articles\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[[\"id\",\"telegram-notes-journey-2026-02-20\",\"d\"],[\"$\",\"$3\",\"c\",{\"children\":[null,[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"articles\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$3\",\"c\",{\"children\":[\"$L8\",null,[\"$\",\"$L9\",null,{\"children\":\"$La\"}]]}],{},null]},null]},null]},null],[\"$\",\"$3\",\"h\",{\"children\":[null,[\"$\",\"$3\",\"mLWF3Mb3e0KxgJiXDMrpD\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}],null]}]]}]]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:I[2647,[\"935\",\"static/chunks/935-c3c4a42486495e3b.js\",\"30\",\"static/chunks/30-cde6a761eaef6c52.js\",\"598\",\"static/chunks/598-8424641e72451bd5.js\",\"406\",\"static/chunks/app/articles/%5Bid%5D/page-b4c9447121244ee6.js\"],\"default\"]\n11:I[7123,[\"935\",\"static/chunks/935-c3c4a42486495e3b.js\",\"30\",\"static/chunks/30-cde6a761eaef6c52.js\",\"598\",\"static/chunks/598-8424641e72451bd5.js\",\"406\",\"static/chunks/app/articles/%5Bid%5D/page-b4c9447121244ee6.js\"],\"default\"]\n14:I[4839,[\"935\",\"static/chunks/935-c3c4a42486495e3b.js\",\"30\",\"static/chunks/30-cde6a761eaef6c52.js\",\"598\",\"static/chunks/598-8424641e72451bd5.js\",\"406\",\"static/chunks/app/articles/%5Bid%5D/page-b4c9447121244ee6.js\"],\"\"]\n12:T2924,"])</script><script>self.__next_f.push([1,"\u003cp\u003e事情的起因很简单：我想要一个\"随手记\"的地方。\u003c/p\u003e\n\u003cp\u003e平时看到什么、想到什么，顺手发一条消息就完事了。但这些零碎的想法散落在聊天记录里或者仅存在与脑海之中，过几天就沉没了。我希望它们能自动汇集到博客的 Notes 页面上——每天的消息归到同一篇，标题就是当天日期，像一份\"碎碎念合集\"。\u003c/p\u003e\n\u003cp\u003e需求说起来就一句话，但真正动手做的时候，发现牵扯的东西远比想象中多，不过好在，基于Codex的给力输出，一下午就把基本功能搞定了。\u003c/p\u003e\n\u003ch2 id=\"选方案为什么是-telegram-bot-webhook\"\u003e选方案：为什么是 Telegram Bot Webhook\u003c/h2\u003e\n\u003cp\u003e一开始摆在面前的核心问题是：怎么把 Telegram 里的消息送到 GitHub 仓库？\u003c/p\u003e\n\u003cp\u003e最终选定的方案是 Telegram Bot Webhook。简单说，Webhook 就是\"你给我一个网址，有事我主动来敲门\"——Telegram 每次收到消息，会主动把内容 POST 到我指定的地址，而不是我反复去轮询\"有没有新消息\"。\u003c/p\u003e\n\u003cp\u003e思路是这样的：我建一个 Bot，私聊发文本给它，Telegram 会把消息推送到 Webhook 地址。Webhook 收到消息后，调用 GitHub API 触发一个 \u003ccode\u003erepository_dispatch\u003c/code\u003e 事件（可以理解为\"远程拍一下 GitHub 的肩膀，告诉它该干活了\"），然后 GitHub Actions 接手，把消息内容写入当天的 Markdown 文件，提交到仓库。最后靠现有的部署流程自动发布到站点。\u003c/p\u003e\n\u003cp\u003e整条链路画出来大概是这样的：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTelegram 私聊 → Bot Webhook → Cloudflare Worker → GitHub repository_dispatch → Actions 脚本写入 notes → commit \u0026#x26; push → 定时部署到 Pages\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e看起来环节不少，但每一环的职责都很清晰。Webhook 只做\"接收和转发\"，Actions 脚本只做\"写文件\"，部署还是复用原来的流程。\u003c/p\u003e\n\u003ch2 id=\"关于-cloudflare-workers一个意外的知识盲区\"\u003e关于 Cloudflare Workers：一个意外的知识盲区\u003c/h2\u003e\n\u003cp\u003e说来有点惭愧，一开始我甚至不太清楚 Cloudflare Workers 是什么。我的第一反应是：能不能直接用我现有的 GitHub Pages 域名来接 Webhook？\u003c/p\u003e\n\u003cp\u003e答案当然是不行——GitHub Pages 是纯静态托管，只能返回 HTML/CSS/JS 文件，没法处理 POST 请求和执行业务逻辑。打个比方，静态托管就像一个只会发传单的展位，你递给它一封信（POST 请求），它不知道怎么拆开、怎么处理。所以还是需要一个真正的\"后端入口\"，哪怕它只有几十行代码。\u003c/p\u003e\n\u003cp\u003eCloudflare Workers 本质上就是一个托管在云端的小型后端函数——你可以把它想象成一个 24 小时在线的小助手，有人敲门（收到请求）它就按你写好的逻辑去办事，办完就休息，不用你租一台一直开着的服务器。免费额度对我这个场景绰绰有余，部署也就是把代码粘进去点一下的事。唯一需要配置的是五个环境变量：Telegram 的 secret token（用来验证请求确实来自 Telegram）、我的聊天 ID 白名单（只接受我自己发的消息）、GitHub 仓库信息和一个最小权限的 PAT（Personal Access Token，相当于 GitHub 的\"临时通行证\"，只给它读写仓库文件的权限）。\u003c/p\u003e\n\u003ch2 id=\"第一个坑worker-还是默认模板\"\u003e第一个坑：Worker 还是默认模板\u003c/h2\u003e\n\u003cp\u003e所有代码写好、环境变量配好之后，我兴冲冲地给 Bot 发了第一条消息。\u003c/p\u003e\n\u003cp\u003eCloudflare 的日志确实收到了请求——但 GitHub Actions 毫无动静。\u003c/p\u003e\n\u003cp\u003e我去看 Worker 的日志，发现一行非常眼熟的输出：\u003ccode\u003eHello World Worker received a request!\u003c/code\u003e。原来我在 Cloudflare 的编辑器里创建 Worker 之后，忘了把默认模板替换成真正的 webhook 代码。它确实收到了 Telegram 的请求，但只是礼貌地回了一句\"Hello World\"，根本没有调用 GitHub API。\u003c/p\u003e\n\u003cp\u003e把代码替换上去、重新部署之后，这一环就通了。\u003c/p\u003e\n\u003ch2 id=\"第二个坑并发推送导致-non-fast-forward\"\u003e第二个坑：并发推送导致 non-fast-forward\u003c/h2\u003e\n\u003cp\u003e消息终于能写入仓库了，但新的问题很快出现。\u003c/p\u003e\n\u003cp\u003e当我短时间内连发几条消息时，GitHub Actions 的 ingest workflow（负责把消息写入文件的自动化流程）会多次并行运行。每个 run 都是拉取 main 分支最新代码、修改文件、提交、推送——但如果前一个 run 已经推送成功，后一个 run 手里的代码就\"过时\"了，\u003ccode\u003egit push\u003c/code\u003e 直接被拒绝，报错信息是 \u003ccode\u003enon-fast-forward\u003c/code\u003e（直译就是\"你的版本不是最新的，不能直接往前推\"）。\u003c/p\u003e\n\u003cp\u003e解决办法不复杂：在 workflow 里给 push 加了重试逻辑，失败时自动拉取远端最新代码、把自己的改动接在后面（\u003ccode\u003egit pull --rebase\u003c/code\u003e），然后重新推送，最多重试四次。同时也加了空变更保护——如果这条消息已经被前一个 run 写入了（也就是做了\u003cstrong\u003e幂等去重\u003c/strong\u003e，下面会解释），就不做无意义的提交。\u003c/p\u003e\n\u003ch2 id=\"第三个坑时间显示错乱\"\u003e第三个坑：时间显示错乱\u003c/h2\u003e\n\u003cp\u003e写入链路稳定之后，我打开网页一看——时间不对。\u003c/p\u003e\n\u003cp\u003e我发的消息明明是北京时间下午 6 点，页面上却显示成了上午 10 点。原因也不难猜：ingest 脚本在 \u003ccode\u003edate\u003c/code\u003e 字段里写入了带 \u003ccode\u003e+08:00\u003c/code\u003e 时区后缀的 ISO 格式（比如 \u003ccode\u003e2026-02-20T18:02:51+08:00\u003c/code\u003e），但站点的构建服务器在 UTC 时区（比北京时间慢 8 小时），渲染的时候直接按 UTC 解读，6 点减 8 小时就变成了上午 10 点。\u003c/p\u003e\n\u003cp\u003e第一次修复的思路是\"在前端强制按 Asia/Shanghai 时区格式化\"。写了几个工具函数，改了列表页、详情页和首页组件。改完确实对了——但我随即意识到一个问题：之前所有手写的文章都用的是不带时区的日期格式（比如 \u003ccode\u003e\"Jan 17 2026\"\u003c/code\u003e 或 \u003ccode\u003e\"2026-01-24\"\u003c/code\u003e），这套新逻辑会不会影响旧文章的显示？\u003c/p\u003e\n\u003cp\u003e最终的决策是\"以旧规则为准\"：前端的时间展示逻辑全部恢复原样，ingest 脚本那边改成写入不带时区后缀的格式，和旧文章保持一致。\u003c/p\u003e\n\u003ch2 id=\"第四个坑定时部署不触发\"\u003e第四个坑：定时部署不触发\u003c/h2\u003e\n\u003cp\u003eGitHub 有一个防循环机制：由自动化流程（\u003ccode\u003eGITHUB_TOKEN\u003c/code\u003e）推送的代码变更，不会再触发其他由 push 事件启动的 workflow。这是为了防止\"A 触发 B，B 又触发 A\"的无限循环。但副作用是：ingest workflow 写完 notes 文件并 push 之后，deploy workflow 压根不知道有新内容，不会自动启动部署。\u003c/p\u003e\n\u003cp\u003e我先是加了 \u003ccode\u003eworkflow_run\u003c/code\u003e 触发，让 deploy 监听 ingest 完成后自动运行。但这样每条消息都会触发一次完整构建，太频繁了。\u003c/p\u003e\n\u003cp\u003e后来改成了\"双通道\"策略：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我自己手动 push 到 main → 立即部署\u003c/li\u003e\n\u003cli\u003eBot 自动写入 → 不立即部署，靠每 30 分钟一次的定时任务检查是否有新变更，有就部署，没有就跳过\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个策略本身没问题，但实际跑起来又碰到了新状况：定时任务的\"是否需要部署\"检查逻辑有 bug。它去查\"最近一次成功的 deploy run\"，结果把 bot push 触发但被 \u003ccode\u003eif\u003c/code\u003e 条件跳过的 run 也算进去了——那个 run 的 \u003ccode\u003ehead_sha\u003c/code\u003e 恰好就是最新的，于是检查结论永远是\"不需要部署\"。\u003c/p\u003e\n\u003cp\u003e修复方式是把并发组按事件类型拆分，同时让 schedule-check 只认\"真正执行过构建的成功 run\"，排除掉被跳过的那些。\u003c/p\u003e\n\u003ch2 id=\"一个小插曲dependabot-带来的分支爆炸\"\u003e一个小插曲：Dependabot 带来的分支爆炸\u003c/h2\u003e\n\u003cp\u003e在处理主线功能的间隙，我顺手给仓库加了 Dependabot 来自动更新依赖——毕竟 \u003ccode\u003enpm audit\u003c/code\u003e 报了一堆告警，其中 Next.js 还有个 critical。\u003c/p\u003e\n\u003cp\u003e结果push一波之后发现，仓库多出了十几个 \u003ccode\u003edependabot/...\u003c/code\u003e 分支，每个依赖包一个 PR。虽然是正常行为，但对于一个人维护的小项目来说，这些 PR 看着就让人焦虑。\u003c/p\u003e\n\u003cp\u003e先是改成了分组更新模式（npm 一组、actions 一组），后来想了想，干脆关掉了——对我来说，偶尔手动跑一次 \u003ccode\u003enpm update\u003c/code\u003e 比每周审核一堆自动 PR 更省心。\u003c/p\u003e\n\u003ch2 id=\"回过头来看\"\u003e回过头来看\u003c/h2\u003e\n\u003cp\u003e这半天下来，从萌生\"随手记\"的念头到整条链路基本跑通，中间经历了方案评估、代码实现、环境配置、五六轮问题排查和策略调整。真正写代码的时间可能并不算多，大部分精力花在了\"让各个环节正确地衔接起来\"上。\u003c/p\u003e\n\u003cp\u003e有几个收获值得记下来：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e写入和发布应该解耦。\u003c/strong\u003e \"解耦\"说白了就是把两件事拆开、各管各的。一开始我本能地觉得\"消息写进去就应该立刻发布\"，但实际上对于碎碎念这种内容，延迟几十分钟完全可以接受。把\"写入仓库\"和\"构建发布网站\"拆成两个独立的步骤之后，构建频率降下来了，并发冲突也少了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e幂等性不是可选项。\u003c/strong\u003e 所谓\"幂等\"，就是\"同一个操作执行一次和执行一百次，结果都一样\"。在这个场景里，Telegram 会重试、Actions 会并发、网络会抖动，同一条消息可能被投递多次。如果 ingest 脚本不按 \u003ccode\u003emessage_id\u003c/code\u003e 做去重——也就是\"这条消息已经写过了，再来一次我就跳过\"——那同一条碎碎念可能会在页面上出现好几遍。这种\"不管来多少次都只生效一次\"的防御性设计，在一开始就该想到。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e尊重已有的约定。\u003c/strong\u003e 时区格式的问题本质上就是\"新代码没有遵循旧约定\"。与其让新功能强推一套新格式，不如让它适配已有的规则，哪怕那个规则不是最\"正确\"的。\u003c/p\u003e\n\u003cp\u003e现在这套东西已经能用了：给 Bot 发条消息，等半小时，网站上就能看到。后续要做的事情不多——观察定时部署的稳定性、找时间升级一下 Next.js 版本、可能的话给 ingest 加几条日志方便排查。\u003c/p\u003e\n\u003cp\u003e总之，它从一个\"要是能这样就好了\"的念头，变成了一条真正可用的自动化链路。这大概就是折腾的乐趣所在。\u003c/p\u003e"])</script><script>self.__next_f.push([1,"13:T2924,"])</script><script>self.__next_f.push([1,"\u003cp\u003e事情的起因很简单：我想要一个\"随手记\"的地方。\u003c/p\u003e\n\u003cp\u003e平时看到什么、想到什么，顺手发一条消息就完事了。但这些零碎的想法散落在聊天记录里或者仅存在与脑海之中，过几天就沉没了。我希望它们能自动汇集到博客的 Notes 页面上——每天的消息归到同一篇，标题就是当天日期，像一份\"碎碎念合集\"。\u003c/p\u003e\n\u003cp\u003e需求说起来就一句话，但真正动手做的时候，发现牵扯的东西远比想象中多，不过好在，基于Codex的给力输出，一下午就把基本功能搞定了。\u003c/p\u003e\n\u003ch2 id=\"选方案为什么是-telegram-bot-webhook\"\u003e选方案：为什么是 Telegram Bot Webhook\u003c/h2\u003e\n\u003cp\u003e一开始摆在面前的核心问题是：怎么把 Telegram 里的消息送到 GitHub 仓库？\u003c/p\u003e\n\u003cp\u003e最终选定的方案是 Telegram Bot Webhook。简单说，Webhook 就是\"你给我一个网址，有事我主动来敲门\"——Telegram 每次收到消息，会主动把内容 POST 到我指定的地址，而不是我反复去轮询\"有没有新消息\"。\u003c/p\u003e\n\u003cp\u003e思路是这样的：我建一个 Bot，私聊发文本给它，Telegram 会把消息推送到 Webhook 地址。Webhook 收到消息后，调用 GitHub API 触发一个 \u003ccode\u003erepository_dispatch\u003c/code\u003e 事件（可以理解为\"远程拍一下 GitHub 的肩膀，告诉它该干活了\"），然后 GitHub Actions 接手，把消息内容写入当天的 Markdown 文件，提交到仓库。最后靠现有的部署流程自动发布到站点。\u003c/p\u003e\n\u003cp\u003e整条链路画出来大概是这样的：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTelegram 私聊 → Bot Webhook → Cloudflare Worker → GitHub repository_dispatch → Actions 脚本写入 notes → commit \u0026#x26; push → 定时部署到 Pages\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e看起来环节不少，但每一环的职责都很清晰。Webhook 只做\"接收和转发\"，Actions 脚本只做\"写文件\"，部署还是复用原来的流程。\u003c/p\u003e\n\u003ch2 id=\"关于-cloudflare-workers一个意外的知识盲区\"\u003e关于 Cloudflare Workers：一个意外的知识盲区\u003c/h2\u003e\n\u003cp\u003e说来有点惭愧，一开始我甚至不太清楚 Cloudflare Workers 是什么。我的第一反应是：能不能直接用我现有的 GitHub Pages 域名来接 Webhook？\u003c/p\u003e\n\u003cp\u003e答案当然是不行——GitHub Pages 是纯静态托管，只能返回 HTML/CSS/JS 文件，没法处理 POST 请求和执行业务逻辑。打个比方，静态托管就像一个只会发传单的展位，你递给它一封信（POST 请求），它不知道怎么拆开、怎么处理。所以还是需要一个真正的\"后端入口\"，哪怕它只有几十行代码。\u003c/p\u003e\n\u003cp\u003eCloudflare Workers 本质上就是一个托管在云端的小型后端函数——你可以把它想象成一个 24 小时在线的小助手，有人敲门（收到请求）它就按你写好的逻辑去办事，办完就休息，不用你租一台一直开着的服务器。免费额度对我这个场景绰绰有余，部署也就是把代码粘进去点一下的事。唯一需要配置的是五个环境变量：Telegram 的 secret token（用来验证请求确实来自 Telegram）、我的聊天 ID 白名单（只接受我自己发的消息）、GitHub 仓库信息和一个最小权限的 PAT（Personal Access Token，相当于 GitHub 的\"临时通行证\"，只给它读写仓库文件的权限）。\u003c/p\u003e\n\u003ch2 id=\"第一个坑worker-还是默认模板\"\u003e第一个坑：Worker 还是默认模板\u003c/h2\u003e\n\u003cp\u003e所有代码写好、环境变量配好之后，我兴冲冲地给 Bot 发了第一条消息。\u003c/p\u003e\n\u003cp\u003eCloudflare 的日志确实收到了请求——但 GitHub Actions 毫无动静。\u003c/p\u003e\n\u003cp\u003e我去看 Worker 的日志，发现一行非常眼熟的输出：\u003ccode\u003eHello World Worker received a request!\u003c/code\u003e。原来我在 Cloudflare 的编辑器里创建 Worker 之后，忘了把默认模板替换成真正的 webhook 代码。它确实收到了 Telegram 的请求，但只是礼貌地回了一句\"Hello World\"，根本没有调用 GitHub API。\u003c/p\u003e\n\u003cp\u003e把代码替换上去、重新部署之后，这一环就通了。\u003c/p\u003e\n\u003ch2 id=\"第二个坑并发推送导致-non-fast-forward\"\u003e第二个坑：并发推送导致 non-fast-forward\u003c/h2\u003e\n\u003cp\u003e消息终于能写入仓库了，但新的问题很快出现。\u003c/p\u003e\n\u003cp\u003e当我短时间内连发几条消息时，GitHub Actions 的 ingest workflow（负责把消息写入文件的自动化流程）会多次并行运行。每个 run 都是拉取 main 分支最新代码、修改文件、提交、推送——但如果前一个 run 已经推送成功，后一个 run 手里的代码就\"过时\"了，\u003ccode\u003egit push\u003c/code\u003e 直接被拒绝，报错信息是 \u003ccode\u003enon-fast-forward\u003c/code\u003e（直译就是\"你的版本不是最新的，不能直接往前推\"）。\u003c/p\u003e\n\u003cp\u003e解决办法不复杂：在 workflow 里给 push 加了重试逻辑，失败时自动拉取远端最新代码、把自己的改动接在后面（\u003ccode\u003egit pull --rebase\u003c/code\u003e），然后重新推送，最多重试四次。同时也加了空变更保护——如果这条消息已经被前一个 run 写入了（也就是做了\u003cstrong\u003e幂等去重\u003c/strong\u003e，下面会解释），就不做无意义的提交。\u003c/p\u003e\n\u003ch2 id=\"第三个坑时间显示错乱\"\u003e第三个坑：时间显示错乱\u003c/h2\u003e\n\u003cp\u003e写入链路稳定之后，我打开网页一看——时间不对。\u003c/p\u003e\n\u003cp\u003e我发的消息明明是北京时间下午 6 点，页面上却显示成了上午 10 点。原因也不难猜：ingest 脚本在 \u003ccode\u003edate\u003c/code\u003e 字段里写入了带 \u003ccode\u003e+08:00\u003c/code\u003e 时区后缀的 ISO 格式（比如 \u003ccode\u003e2026-02-20T18:02:51+08:00\u003c/code\u003e），但站点的构建服务器在 UTC 时区（比北京时间慢 8 小时），渲染的时候直接按 UTC 解读，6 点减 8 小时就变成了上午 10 点。\u003c/p\u003e\n\u003cp\u003e第一次修复的思路是\"在前端强制按 Asia/Shanghai 时区格式化\"。写了几个工具函数，改了列表页、详情页和首页组件。改完确实对了——但我随即意识到一个问题：之前所有手写的文章都用的是不带时区的日期格式（比如 \u003ccode\u003e\"Jan 17 2026\"\u003c/code\u003e 或 \u003ccode\u003e\"2026-01-24\"\u003c/code\u003e），这套新逻辑会不会影响旧文章的显示？\u003c/p\u003e\n\u003cp\u003e最终的决策是\"以旧规则为准\"：前端的时间展示逻辑全部恢复原样，ingest 脚本那边改成写入不带时区后缀的格式，和旧文章保持一致。\u003c/p\u003e\n\u003ch2 id=\"第四个坑定时部署不触发\"\u003e第四个坑：定时部署不触发\u003c/h2\u003e\n\u003cp\u003eGitHub 有一个防循环机制：由自动化流程（\u003ccode\u003eGITHUB_TOKEN\u003c/code\u003e）推送的代码变更，不会再触发其他由 push 事件启动的 workflow。这是为了防止\"A 触发 B，B 又触发 A\"的无限循环。但副作用是：ingest workflow 写完 notes 文件并 push 之后，deploy workflow 压根不知道有新内容，不会自动启动部署。\u003c/p\u003e\n\u003cp\u003e我先是加了 \u003ccode\u003eworkflow_run\u003c/code\u003e 触发，让 deploy 监听 ingest 完成后自动运行。但这样每条消息都会触发一次完整构建，太频繁了。\u003c/p\u003e\n\u003cp\u003e后来改成了\"双通道\"策略：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我自己手动 push 到 main → 立即部署\u003c/li\u003e\n\u003cli\u003eBot 自动写入 → 不立即部署，靠每 30 分钟一次的定时任务检查是否有新变更，有就部署，没有就跳过\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个策略本身没问题，但实际跑起来又碰到了新状况：定时任务的\"是否需要部署\"检查逻辑有 bug。它去查\"最近一次成功的 deploy run\"，结果把 bot push 触发但被 \u003ccode\u003eif\u003c/code\u003e 条件跳过的 run 也算进去了——那个 run 的 \u003ccode\u003ehead_sha\u003c/code\u003e 恰好就是最新的，于是检查结论永远是\"不需要部署\"。\u003c/p\u003e\n\u003cp\u003e修复方式是把并发组按事件类型拆分，同时让 schedule-check 只认\"真正执行过构建的成功 run\"，排除掉被跳过的那些。\u003c/p\u003e\n\u003ch2 id=\"一个小插曲dependabot-带来的分支爆炸\"\u003e一个小插曲：Dependabot 带来的分支爆炸\u003c/h2\u003e\n\u003cp\u003e在处理主线功能的间隙，我顺手给仓库加了 Dependabot 来自动更新依赖——毕竟 \u003ccode\u003enpm audit\u003c/code\u003e 报了一堆告警，其中 Next.js 还有个 critical。\u003c/p\u003e\n\u003cp\u003e结果push一波之后发现，仓库多出了十几个 \u003ccode\u003edependabot/...\u003c/code\u003e 分支，每个依赖包一个 PR。虽然是正常行为，但对于一个人维护的小项目来说，这些 PR 看着就让人焦虑。\u003c/p\u003e\n\u003cp\u003e先是改成了分组更新模式（npm 一组、actions 一组），后来想了想，干脆关掉了——对我来说，偶尔手动跑一次 \u003ccode\u003enpm update\u003c/code\u003e 比每周审核一堆自动 PR 更省心。\u003c/p\u003e\n\u003ch2 id=\"回过头来看\"\u003e回过头来看\u003c/h2\u003e\n\u003cp\u003e这半天下来，从萌生\"随手记\"的念头到整条链路基本跑通，中间经历了方案评估、代码实现、环境配置、五六轮问题排查和策略调整。真正写代码的时间可能并不算多，大部分精力花在了\"让各个环节正确地衔接起来\"上。\u003c/p\u003e\n\u003cp\u003e有几个收获值得记下来：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e写入和发布应该解耦。\u003c/strong\u003e \"解耦\"说白了就是把两件事拆开、各管各的。一开始我本能地觉得\"消息写进去就应该立刻发布\"，但实际上对于碎碎念这种内容，延迟几十分钟完全可以接受。把\"写入仓库\"和\"构建发布网站\"拆成两个独立的步骤之后，构建频率降下来了，并发冲突也少了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e幂等性不是可选项。\u003c/strong\u003e 所谓\"幂等\"，就是\"同一个操作执行一次和执行一百次，结果都一样\"。在这个场景里，Telegram 会重试、Actions 会并发、网络会抖动，同一条消息可能被投递多次。如果 ingest 脚本不按 \u003ccode\u003emessage_id\u003c/code\u003e 做去重——也就是\"这条消息已经写过了，再来一次我就跳过\"——那同一条碎碎念可能会在页面上出现好几遍。这种\"不管来多少次都只生效一次\"的防御性设计，在一开始就该想到。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e尊重已有的约定。\u003c/strong\u003e 时区格式的问题本质上就是\"新代码没有遵循旧约定\"。与其让新功能强推一套新格式，不如让它适配已有的规则，哪怕那个规则不是最\"正确\"的。\u003c/p\u003e\n\u003cp\u003e现在这套东西已经能用了：给 Bot 发条消息，等半小时，网站上就能看到。后续要做的事情不多——观察定时部署的稳定性、找时间升级一下 Next.js 版本、可能的话给 ingest 加几条日志方便排查。\u003c/p\u003e\n\u003cp\u003e总之，它从一个\"要是能这样就好了\"的念头，变成了一条真正可用的自动化链路。这大概就是折腾的乐趣所在。\u003c/p\u003e"])</script><script>self.__next_f.push([1,"8:[\"$\",\"main\",null,{\"className\":\"min-h-screen pb-20\",\"children\":[[\"$\",\"$L10\",null,{}],[\"$\",\"$L11\",null,{\"contentHtml\":\"$12\"}],[\"$\",\"article\",null,{\"className\":\"container-custom relative md-theme-amp-outer\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-10\",\"children\":[\"\",[\"$\",\"h1\",null,{\"className\":\"text-3xl md:text-4xl font-bold mb-4 text-center font-serif text-[#3e3832] dark:text-[#f0f6fc]\",\"children\":\"从一个念头到自动化链路：Telegram 碎碎念入站记\"}],[\"$\",\"p\",null,{\"className\":\"text-xl text-muted mb-4\",\"children\":\"一天之内打通 Telegram → GitHub → 博客的随手记功能\"}],[\"$\",\"div\",null,{\"className\":\"text-sm text-muted\",\"children\":\"2026-02-20\"}]]}],[\"$\",\"div\",null,{\"className\":\"prose md-theme-amp\",\"dangerouslySetInnerHTML\":{\"__html\":\"$13\"}}],false,[\"$\",\"div\",null,{\"className\":\"mt-16 pt-8 border-t border-[var(--border-subtle)]\",\"children\":[\"$\",\"$L14\",null,{\"href\":\"/articles\",\"className\":\"text-accent hover:text-foreground transition-colors\",\"children\":\"← Back to Articles\"}]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"e:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"从一个念头到自动化链路：Telegram 碎碎念入站记 - AlpacaNotes\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"记录把 Telegram 随手笔记自动汇总到博客 Notes 页面的全过程，包括方案选型、逐步落地和一路踩过的坑。\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:title\",\"content\":\"从一个念头到自动化链路：Telegram 碎碎念入站记 - AlpacaNotes\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:description\",\"content\":\"记录把 Telegram 随手笔记自动汇总到博客 Notes 页面的全过程，包括方案选型、逐步落地和一路踩过的坑。\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:url\",\"content\":\"https://linguista.cn/alpacanotes/articles/telegram-notes-journey-2026-02-20\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:image\",\"content\":\"https://linguista.cn/alpacanotes/aztecaalpaca.jpg\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"8\",{\"property\":\"article:published_time\",\"content\":\"2026-02-20\"}],[\"$\",\"meta\",\"9\",{\"property\":\"article:author\",\"content\":\"@linguista2025\"}],[\"$\",\"meta\",\"10\",{\"property\":\"article:tag\",\"content\":\"Telegram\"}],[\"$\",\"meta\",\"11\",{\"property\":\"article:tag\",\"content\":\"GitHub Actions\"}],[\"$\",\"meta\",\"12\",{\"property\":\"article:tag\",\"content\":\"Cloudflare Workers\"}],[\"$\",\"meta\",\"13\",{\"property\":\"article:tag\",\"content\":\"自动化\"}],[\"$\",\"meta\",\"14\",{\"property\":\"article:tag\",\"content\":\"开发记录\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:title\",\"content\":\"从一个念头到自动化链路：Telegram 碎碎念入站记 - AlpacaNotes\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:description\",\"content\":\"记录把 Telegram 随手笔记自动汇总到博客 Notes 页面的全过程，包括方案选型、逐步落地和一路踩过的坑。\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:image\",\"content\":\"https://linguista.cn/alpacanotes/aztecaalpaca.jpg\"}],[\"$\",\"link\",\"19\",{\"rel\":\"icon\",\"href\":\"/alpacanotes/favicon.svg\",\"type\":\"image/svg+xml\"}]]\n"])</script><script>self.__next_f.push([1,"a:null\n"])</script></body></html>